[{"authors":["admin"],"categories":null,"content":"Nelson Bighetti is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed neque elit, tristique placerat feugiat ac, facilisis vitae arcu. Proin eget egestas augue. Praesent ut sem nec arcu pellentesque aliquet. Duis dapibus diam vel metus tempus vulputate.\n","date":1572333311,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":1572333311,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"https://wangxinping.github.io/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"Nelson Bighetti is a professor of artificial intelligence at the Stanford AI Lab. His research interests include distributed robotics, mobile computing and programmable matter. He leads the Robotic Neurobiology group, which develops self-reconfiguring robots, systems of self-organizing robots, and mobile sensor networks.\nLorem ipsum dolor sit amet, consectetur adipiscing elit. Sed neque elit, tristique placerat feugiat ac, facilisis vitae arcu. Proin eget egestas augue. Praesent ut sem nec arcu pellentesque aliquet.","tags":null,"title":"WangXinping","type":"authors"},{"authors":["WangXinping"],"categories":["Interview"],"content":"mysql数据存储是怎么组织的\n mysql索引是怎么组织的，有什什么需要注意的地⽅方 主键与其它索引的区别 java/c++多态是怎么实现的 ⽅方法调⽤用时⽅方法栈的动作，哪些资源需要压栈，锁是否需要压栈 锁实现机制 垃圾回收算法，root节点，资源引⽤用计数为0后，⻢马上就回收资源吗？有没 有办法再次获取并使⽤用此资源 多态是如何实现的  ","date":1572333311,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1572333311,"objectID":"5eeb8e75b90168228348200cfcab9274","permalink":"https://wangxinping.github.io/post/tips-for-interview/","publishdate":"2019-10-29T15:15:11+08:00","relpermalink":"/post/tips-for-interview/","section":"post","summary":"mysql数据存储是怎么组织的 mysql索引是怎么组织的，有什什么需要注意的地⽅方 主键与其它索引的区别 java/c++多态是怎么实现的 ⽅方法","tags":["Interview"],"title":"Tips for Interview","type":"post"},{"authors":["WangXinping"],"categories":["Markdown"],"content":"","date":1571376051,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1571376051,"objectID":"f60723b11c6a4deee552d9ee35c80a39","permalink":"https://wangxinping.github.io/post/welcome-to-markdown/","publishdate":"2019-10-18T13:20:51+08:00","relpermalink":"/post/welcome-to-markdown/","section":"post","summary":"","tags":["Markdown"],"title":"Welcome to Markdown","type":"post"},{"authors":["WangXinping"],"categories":["Git"],"content":"SSH 密钥 生成 SSH 密钥 $ ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; 配置 SSH 公钥到服务器 $ ssh-copy-id -i ~/.ssh/id_rsa.pub username@server_host 基本配置 配置个人信息  全局配置  $ git config --global user.name \u0026#34;[name]\u0026#34; $ git config --global user.email \u0026#34;[email address]\u0026#34; $ git config --global color.ui auto  项目配置  $ git config user.name \u0026#34;[name]\u0026#34; $ git config user.email \u0026#34;[email address]\u0026#34;  查看配置  $ git config --list user.name=John Doe user.email=johndoe@example.com 新建 Git 仓库  Server  $ cd /git_repository_path $ mkdir project.git $ cd project.git $ git init --bare Initialized empty Git repository in /git_repository_path/project.git/  Client  $ git clone git@gitserver:/git_repository_path/project.git $ cd project $ vim README $ git add . $ git commit -m \u0026#39;update the README file\u0026#39; $ git push -u origin master 忽略规则  在 .gitignore 文件中我们可以配置需要忽略哪些文件和文件夹。注意，这个文件仅对还没有被纳入 Git 版本管理的文件生效，要停止已被追踪文件的版本管理可以使用命令git rm --cached。\n 规则  空行不匹配作何文件，可以用空行来做来分隔以增强可读性。 以 # 开头的行代表注释。但如果在 # 前面有一个转义字符（\\）则匹配井号（#）。 一般情况下行尾的空格会被忽略，但当空格前有转义字符（\\）时除外。 ! 前缀用于取反，即 ! 后面匹配到的本应该被排除的文件会被加入进来。但如果某文件的父目录已被排除，则该文件不会被再次加入进来，所以任何被包含在其它匹配项里面文件的匹配不会生效，不管它是在哪里配置的。另外，带转义的 !（\\!）匹配 ! 本身。 / 被用作目录分隔符，可被用于匹配模式的开头、中间或末尾。 如果匹配模式开头或中间（或两者都有）存在 /，则模式是相对于 .gitignore 文件所在目录的。否则，模式还会匹配 .gitignore 文件所在目录的任意层次的子目录。 如果匹配模式末尾存在 /，则模式匹配只会匹配目录。否则，模式会匹配目录和文件。 举例说明，doc/frotz/ 会匹配 doc/frotz 目录，但不会匹配 a/doc/frotz 目录；但是，frotz/ 会匹配 frotz，a/frotz 等相对于 .gitignore 文件的所有能匹配的目录。 * 能匹配除 / 之外的任何东西。? 能匹配除 / 之外的任意单个字符。区间模式（如 [a-zA-Z）能匹配在区间内的单个字符。 连续星号（**）对匹配路径名有特殊含义：  以 ** 开头，紧跟着 / 匹配所有目录。例如，**/foo 匹配任意位置的 foo 目录或文件，跟 foo 模式一样；**/foo/bar 匹配任意位置在 foo 目录直接包含的 bar 文件或目录。 以 ** 结尾，匹配里面的所有文件或目录。例如，abc/** 匹配相对于 .gitignore 文件的 abc 目录下的所有文件或目录，不限深度。 / 后面紧跟着 ** 后面再跟 / 匹配零个或多个目录。例如，a/**/b 匹配 a/b，a/x/b，a/x/y/b，等等。    举例  hello.* 匹配任何以 hello. 开头的文件或目录。如果要限制子目录匹配，可以在前面加上 /，如 /hello.*，现在该模式能匹配 hello.txt，hello.c，但不能匹配 a/hello.java。 foo/ 可以匹配任意层次的 foo 目录，但是不能匹配 foo 文件。 doc/frotz 和 /doc/frotz 匹配效果相同，换句话说，如果模式中间有 /，则开头的 / 不是必须的。 foo/* 可以匹配 foo/test.json（一个文件），foo/bar（一个目录），但不会匹配 foo/bar/hello.c，因为单个 * 不会匹配带有 / 的路径。  常用命令 新建/检出仓库  新建本地仓库  $ git init [project-name]  检出仓库  $ git clone [url] 编辑提交  列出所有文件变化（新建或修改），查看仓库状态  $ git status  显示未暂存文件的改动  $ git diff  显示暂存区文件与最近版本的区别  $ git diff --staged  添加文件到暂存区  $ git add [file] $ git add .  取消暂存，但保持文件内容不变  $ git reset [file]  将暂存区内容提交到当前分支  $ git commit -m \u0026#34;[descriptive message]\u0026#34;  注释可以通过单引号来换行\n $ git commit -m \u0026#39; \u0026gt; 1.提交内容 \u0026gt; 2.注释文本 \u0026gt; \u0026#39;  git add 和 git commit 可以合在一起写\n $ git commit -am \u0026#34;代码提交注释\u0026#34; $ git commit -a -m \u0026#34;代码提交注释\u0026#34; 操作分支  列出所有本地分支（前面有 * 的为当前分支）  $ git branch  查看远程分支  $ git branch -r  查看所有分支（本地 + 远程）  $ git branch -a  创建新分支  $ git branch [branch-name]  切换到指定分支并更新工作目录  $ git checkout [branch-name]  创建并切换分支快捷命令（相当于上面两个命令的合体）  $ git checkout -b [branch-name]  修改分支名称  $ git branch -m [old-branch-name] [new-branch-name]  切换回主分支  $ git checkout master  合并指定分支到当前分支  $ git merge [branch]  合并分支时，Git 会默认用 Fast forward 模式，此模式下，删除分支后，会丢掉分支信息；而且当所有分支都有改动时，容易出错，建议添加 --no-ff 参数，禁用 Fast forward 模式\n  合并分支时，加上 --no-ff 参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而 Fast forward 合并就看不出来曾经做过合并。合并时要创建一个新的 commit，所以加上 -m 参数，把 commit 描述写进去。  $ git merge --no-ff -m \u0026#34;merge with --no-ff\u0026#34; [branch-name]  删除指定分支  $ git branch -d [branch-name]  强行删除指定分支  $ git branch -D [branch-name] 重构文件  Relocate and remove versioned files\n  从工作目录删除文件并暂存此删除操作  $ git rm [file]  从版本控制系统删除文件但保留对应本地文件  $ git rm --cached [file]  修改文件名并准备提交  $ git mv [file-original] [file-renamed] 排除（.gitignore）  Exclude temporary files and paths\n  列出当前项目所有排除文件  $ git ls-files --other --ignored --exclude-standard 保存工作现场  存储当前工作现场，等以后恢复现场后继续工作  $ git stash  恢复存储的工作现场，恢复的同时把 stash 内容也删掉  $ git stash pop  查看存储的工作现场  $ git stash list  可以多次 stash，恢复的时候，先用 git stash list 查看，然后恢复指定的stash  $ git stash apply stash@{0}  丢弃最近存储的工作现场  $ git stash drop 检查历史  列出当前分支版本历史  $ git log  列出文件版本历史，包含重命名。  $ git log --follow [file]  log 输出信息压缩命令  $ git log --pretty=oneline  查看指定文件版本库日志  $ git log [filename]  查看分支合并图  $ git log --graph $ git log --graph --pretty=oneline --abbrev-commit  查看 log 参数的更多信息  $ git log --help  查看分支间的差异  $ git diff [first-branch]...[second-branch]  查看分支之间的差异。在合并改动之前，你可以使用如下命令预览差异。  $ git diff [source-branch-name] [target-branch-name]  输出特定提交的元数据和修改的内容  $ git show [commit]  查看HEAD的移动历史  $ git reflog 版本回退  撤回所有提交，但保留本地改动。  $ git reset [commit]  丢弃所有历史和修改并回到特定提交  $ git reset --hard [commit]  回到当前版本，放弃所有没有提交的修改。  $ git reset --hard HEAD  回到上个版本  $ git reset --hard HEAD^  回到上上个版本  $ git reset --hard HEAD^^  回到往上的第6个版本  $ git reset --hard HEAD~6  回到指定版本号的版本（3628164 这段数字是 commit id，也就是所谓的版本号，它是一大串字符串的前几位，我们没必要把一整串 commit id 都写出来）  $ git reset --hard 3628164 同步修改  Downloads all history from the repository bookmark  $ git fetch [bookmark]  Combines bookmark’s branch into current local branch  $ git merge [bookmark]/[branch]  Uploads all local branch commits to GitHub  $ git push [alias] [branch]  Downloads bookmark history and incorporates changes  $ git pull 远程仓库  关联一个远程仓库  $ git remote add origin [url]  第一次推送 master 分支的所有内容，使用 -u 参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来。此后，每次本地提交后，只要有必要，就可以使用命令 git push origin master 推送最新修改。  $ git push -u origin master  推送最新修改  $ git push origin master  除非你将分支推送到远端仓库，不然他人就看不到该分支  $ git push origin [branch-name]  查看远程仓库地址  $ git remote -v 标签  查看所有标签  $ git tag  切换到需要打标签的分支上，使用下面命令就可以打一个新标签（标签是默认打在最新提交的 commit 上的）  $ git tag [tag-name]  打标签到指定的 commit 上  $ git tag [tag-name] [commit-id]  查看标签信息  $ git show [tag-name]  创建带有说明的标签。-a：指定标签名，-m：指定说明文字  $ git tag -a [tag-name] -m \u0026#34;tag description\u0026#34; [commit-id]  删除本地标签  $ git tag -d [tag-name]  推送指定标签到远程  $ git push origin [tag-name]  推送全部尚未推送到远程的本地标签  $ git push origin --tags  删除指定远程标签（在删除远程标签之前，要先从本地删除）  $ git push origin :refs/tags/[tag-name] ","date":1571314368,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1571314368,"objectID":"3e0adc7e051b548e13801d4989eb8c1d","permalink":"https://wangxinping.github.io/post/welcome-to-git/","publishdate":"2019-10-17T20:12:48+08:00","relpermalink":"/post/welcome-to-git/","section":"post","summary":"SSH 密钥 生成 SSH 密钥 $ ssh-keygen -t rsa -b 4096 -C \u0026#34;your_email@example.com\u0026#34; 配置 SSH 公钥到服务器 $ ssh-copy-id -i ~/.ssh/id_rsa.pub username@server_host 基本配置 配置个人信息 全局配置 $ git config --global user.name \u0026#34;[name]\u0026#34; $ git config --global user.email \u0026#34;[email address]\u0026#34; $ git config --global color.ui auto 项目配置 $ git config","tags":["Git"],"title":"Welcome to Git","type":"post"},{"authors":["WangXinping"],"categories":["Spring","Spring Security"],"content":"配置步骤 1. pom \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.thymeleaf.extras\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-extras-springsecurity4\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 2. 配置WebSecurityConfigurerAdapter，SpringSecurty核心配置文件 package tools.perkinelmer.Config; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder; import org.springframework.security.config.annotation.web.builders.HttpSecurity; import org.springframework.security.config.annotation.web.builders.WebSecurity; import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity; import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter; import org.springframework.security.core.userdetails.UserDetailsService; import tools.perkinelmer.security.CustomUserService; @Configuration @EnableWebSecurity public class WebSecurityConfig extends WebSecurityConfigurerAdapter { @Bean UserDetailsService customUserService(){ //注册UserDetailsService 的bean  return new CustomUserService(); } @Override protected void configure(AuthenticationManagerBuilder auth) throws Exception { auth.userDetailsService(customUserService()); //user Details Service验证  } @Override protected void configure(HttpSecurity http) throws Exception { http.authorizeRequests() .anyRequest().authenticated() //任何请求,登录后可以访问  .and() .formLogin() .loginPage(\u0026#34;/login\u0026#34;) .defaultSuccessUrl(\u0026#34;/main\u0026#34;) .failureUrl(\u0026#34;/login?error\u0026#34;) .permitAll() //登录页面用户任意访问  .and() .headers().frameOptions().disable() .and() .logout().permitAll(); //注销行为任意访问  } @Override public void configure(WebSecurity web) throws Exception { //解决静态资源被拦截的问题  web.ignoring().antMatchers(\u0026#34;/**/*.js\u0026#34;, \u0026#34;/**/*.css\u0026#34;, \u0026#34;/**/*.jpg\u0026#34;, \u0026#34;/**/*.png\u0026#34;); } } 3. 配置MVC,主要作用添加登录页面，主页面，页面映射，从而达到通过配置文件配置就能使thymeleaf从后台出来，内部应用起作用 package tools.perkinelmer.Config; import org.springframework.context.annotation.Configuration; import org.springframework.web.servlet.config.annotation.ViewControllerRegistry; import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter; @Configuration public class WebMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\u0026#34;/login\u0026#34;).setViewName(\u0026#34;login/login\u0026#34;); registry.addViewController(\u0026#34;/main\u0026#34;).setViewName(\u0026#34;main/main\u0026#34;); } } 4. 配置用户，角色，并将权限交给SpringSceurity来处理 SysRole package tools.perkinelmer.entity; public class SysRole { private Integer id; private String name; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } } SysUser package tools.perkinelmer.entity; import java.util.List; public class SysUser { private Integer id; private String username; public Integer getId() { return id; } public void setId(Integer id) { this.id = id; } public String getUsername() { return username; } public void setUsername(String username) { this.username = username; } public String getPassword() { return password; } public void setPassword(String password) { this.password = password; } public List\u0026lt;SysRole\u0026gt; getRoles() { return roles; } public void setRoles(List\u0026lt;SysRole\u0026gt; roles) { this.roles = roles; } private String password; private List\u0026lt;SysRole\u0026gt; roles; } 自定义UserDetailsService让权限控制交给springSecrity package tools.perkinelmer.security; import java.util.ArrayList; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.core.userdetails.UsernameNotFoundException; import tools.perkinelmer.Mapper.UserMapper; import tools.perkinelmer.entity.SysRole; import tools.perkinelmer.entity.SysUser; /** * 用于将用户权限交给 springsecurity 进行管控 */ public class CustomUserService implements UserDetailsService{ @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { SysUser user = userMapper.findByUserName(username); if(user == null){ throw new UsernameNotFoundException(\u0026#34;用户名不存在\u0026#34;); } List\u0026lt;SimpleGrantedAuthority\u0026gt; authorities = new ArrayList\u0026lt;\u0026gt;(); //用于添加用户的权限。只要把用户权限添加到authorities 就万事大吉。  for(SysRole role:user.getRoles()) { authorities.add(new SimpleGrantedAuthority(role.getName())); System.out.println(role.getName()); } return new org.springframework.security.core.userdetails.User(user.getUsername(), user.getPassword(), authorities); } } 5. 相关页面  写好配置文件指定的登录页面，如果不指定的话springSecurty有自己默认的，登录成功后写好指定的主页，这里都需要用thymeleaf模板来做，这样权限控制可以有 sec:authorize=\u0026quot;hasRole(\u0026lsquo;ROLE_ADMIN\u0026rsquo;)\u0026ldquo;来控制哪些元素显示与否，用户是否有权限访问 权限名称需要是ROLE_开头的\n 6. SpringSercity配置需要注意点  首先当我们要自定义Spring Security的时候我们需要继承自WebSecurityConfigurerAdapter来完成，相关配置重写对应 方法即可。 我们在这里注册CustomUserService的Bean，然后通过重写configure方法添加我们自定义的认证方式。 在configure(HttpSecurity http)方法中，我们设置了登录页面，而且登录页面任何人都可以访问，然后设置了登录失败地址，也设置了注销请求，注销请求也是任何人都可以访问的。 permitAll表示该请求任何人都可以访问，.anyRequest().authenticated(),表示其他的请求都必须要有权限认证。 这里我们可以通过匹配器来匹配路径，比如antMatchers方法，假设我要管理员才可以访问admin文件夹下的内容，我可以这样来写：.antMatchers(\u0026quot;/admin/**\u0026quot;).hasRole(\u0026quot;ROLE_ADMIN\u0026quot;)，也可以设置admin文件夹下的文件可以有多个角色来访问，写法如下：.antMatchers(\u0026quot;/admin/**\u0026quot;).hasAnyRole(\u0026quot;ROLE_ADMIN\u0026quot;,\u0026quot;ROLE_USER\u0026quot;) 可以通过hasIpAddress来指定某一个ip可以访问该资源,假设只允许访问ip为210.210.210.210的请求获取admin下的资源，写法如下.antMatchers(\u0026quot;/admin/**\u0026quot;).hasIpAddress(\u0026quot;210.210.210.210\u0026quot;) 更多的权限控制方式参看下表：  分析理解 1. SpringSecurity运行机制  被认证请求被FilterSecurityInterceptor拦截看有没有对应权限，如果没有抛异常给ExceptionTranslationFilter ExceptionTranslationFilter缓存原请求，利用LoginUrlAuthenticationEntryPoint入口跳转到登录界面 用户在登录界面填写登录信息后，提交，经过UsernamePasswordAuthenticationFilter对填写的信息和从数据源中获取的信息进行对比，成功则授权权限，并通过登录成功后入口SavedRequestAwareAuthenticationSuccessHandler跳转回原请求页面（跳转时有从缓存中对请求信息的恢复） 登录完成后返回原请求，由FilterSecurityInterceptor进行权限的验证（大部分工作有AbstractSecurityInterceptor来做），根据登录成功后生成的Authentication（Authentication authentication = SecurityContextHolder.getContext().getAuthentication();由SecurityContextHolder持有，而其中的SecurityContext由SecurityContextPersistentFilter保存到session中从而实现request共享）中的权限和请求所需的权限对比，如果一致则成功执行，如果权限不正确则返回403错误码 以上均是默认情况下，没有经过配置的执行过程，当然可以自定义LoginUrlAuthenticationEntryPoint和SavedRequestAwareAuthenticationSuccessHandler实现根据不同的请求所需权限跳转到不同登录页面及授权成功后根据权限跳转到不同页面，以及返回403错误码时跳转到对应的页面（AccessDeniedHandlerImpl）在下一篇中会对其进行实现  2. 根据这个机制我们可以做的事  自定义LoginUrlAuthenticationEntryPoint实现跳转到不同登录页，如用户订单请求跳转到用户登录页，管理中心请求跳转到管理员登录页 自定义SavedRequestAwareAuthenticationSuccessHandler实现直接点击登录成功后跳转到指定的页，如用户登录后跳转到首页，管理员登陆后跳转到管理中心 通过AccessDeniedHandlerImpl处理虽让登录成功确没有访问权限的问题 自定义SimpleUrlAuthenticationFailureHandler来实现登录失败的情况，主要是用户不存在或密码错误问题。这种情况下能够实现从哪个登录页面过来的还是返回原登录页，并携带错误信息 SimpleUrlAuthenticationSuccessHandler  3. thymeleaf  这个模板使用必须是通过后台获得内部组件才能与java代码融合起作用，这里我们需要注意的地方是需要通过后台访问的页面都要 用WebMvcConfigurerAdapter配置下\n @Configuration public class WebMvcConfig extends WebMvcConfigurerAdapter { @Override public void addViewControllers(ViewControllerRegistry registry) { registry.addViewController(\u0026#34;/login\u0026#34;).setViewName(\u0026#34;login/login\u0026#34;); registry.addViewController(\u0026#34;/main\u0026#34;).setViewName(\u0026#34;main/main\u0026#34;); } } 4. 角色权限控制  springsecurity的角色权限控制，可通过配置角色组来作为角色，原来的角色作为权限，之后这个权限选项就可以作为控制页面元素显示，指定url访问的控制元素\n package tools.perkinelmer.security; import java.util.ArrayList; import java.util.List; import org.springframework.beans.factory.annotation.Autowired; import org.springframework.security.core.authority.SimpleGrantedAuthority; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.security.core.userdetails.UserDetailsService; import org.springframework.security.core.userdetails.UsernameNotFoundException; import tools.perkinelmer.Mapper.UserMapper; import tools.perkinelmer.entity.SysAuthority; import tools.perkinelmer.entity.SysRole; import tools.perkinelmer.entity.SysUser; /** * 用于将用户权限交给 springsecurity 进行管控 * */ public class CustomUserService implements UserDetailsService{ @Autowired private UserMapper userMapper; @Override public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException { SysUser user = userMapper.findByUserName(username); if(user == null){ throw new UsernameNotFoundException(\u0026#34;用户名不存在\u0026#34;); } List\u0026lt;SimpleGrantedAuthority\u0026gt; authorities = new ArrayList\u0026lt;\u0026gt;(); //用于添加用户的权限。只要把用户权限添加到authorities 就万事大吉。  for(SysRole role:user.getRoles()) { List\u0026lt;SysAuthority\u0026gt; authoritys = role.getAuthoritys(); for(SysAuthority authority:authoritys){ authorities.add(new SimpleGrantedAuthority(\u0026#34;ROLE_\u0026#34;+authority.getAuthority_id().toString())); } } return new org.springframework.security.core.userdetails.User(user.getUsername(), user.getPassword(), authorities); } } ","date":1571313891,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1571313891,"objectID":"405bdb91dc77bc44335df4d6e718eb4c","permalink":"https://wangxinping.github.io/post/welcome-to-spring-security/","publishdate":"2019-10-17T20:04:51+08:00","relpermalink":"/post/welcome-to-spring-security/","section":"post","summary":"配置步骤 1. pom \u0026lt;dependencies\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-web\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.security\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-security-config\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.thymeleaf.extras\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;thymeleaf-extras-springsecurity4\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; 2. 配置WebSecurityConfigurerAdapter，SpringSecurty核心配置文","tags":["Spring","Spring Security"],"title":"Welcome to Spring Security","type":"post"},{"authors":["WangXinping"],"categories":["MySQL"],"content":"CentOS 7 使用 MariaDB 代替 MYSQL  本文记录在 CentOS 7 中使用 MySQL/MariaDB 的一些用法和一些要注意的事情\n 安装 MariaDB  安装MariaDB  $ yum install mariadb mariadb-server mariadb-devel  启动MariaDB  $ systemctl start mariadb # 或者 $ service mariadb start  设置开机启动  $ systemctl enable mariadb # 或者 $ chkconfig mariadb on  接下来进行MariaDB的相关简单配置  $ mysql_secure_installation # 首先是设置密码，会提示先输入密码 Enter current password for root (enter for none):\u0026lt;–初次运行直接回车 # 设置密码 Set root password? `[Y/n]` \u0026lt;– 是否设置root用户密码，输入y回车或直接回车 New password: \u0026lt;– 设置root用户的密码 Re-enter new password: \u0026lt;– 再输入一次你设置的密码 # 其他配置 Remove anonymous users? `[Y/n]` \u0026lt;– 是否删除匿名用户 Disallow root login remotely? `[Y/n]` \u0026lt;–是否禁止root远程登录 Remove test database and access to it? `[Y/n]` \u0026lt;– 是否删除test数据库 Reload privilege tables now? `[Y/n]` \u0026lt;– 是否重新加载权限表 # 初始化MariaDB完成，接下来测试登录`mysql -uroot -ppassword` # 完成 配置 MariaDB 的字符集(utf8或utf8mb4) 文件/etc/my.cnf\n$ vi /etc/my.cnf 在[mysqld]标签下添加\ninit_connect='SET collation_connection = utf8_general_ci' init_connect='SET NAMES utf8' character-set-server=utf8 collation-server=utf8_general_ci skip-character-set-client-handshake 文件/etc/my.cnf.d/client.cnf\n$ vi /etc/my.cnf.d/client.cnf 在[client]中添加\ndefault-character-set=utf8 文件/etc/my.cnf.d/mysql-clients.cnf\n$ vi /etc/my.cnf.d/mysql-clients.cnf 在[mysql]中添加\ndefault-character-set=utf8 全部配置完成，重启 mariadb\n$ systemctl restart mariadb 之后进入MariaDB查看字符集\nmysql\u0026gt; show variables like \u0026#34;%character%\u0026#34;;show variables like \u0026#34;%collation%\u0026#34;; +--------------------------+----------------------------+ | Variable_name | Value | +--------------------------+----------------------------+ | character_set_client | utf8 | | character_set_connection | utf8 | | character_set_database | utf8 | | character_set_filesystem | binary | | character_set_results | utf8 | | character_set_server | utf8 | | character_set_system | utf8 | | character_sets_dir | /usr/share/mysql/charsets/ | +--------------------------+----------------------------+ 8 rows in set (0.00 sec) +----------------------+-----------------+ | Variable_name | Value | +----------------------+-----------------+ | collation_connection | utf8_general_ci | | collation_database | utf8_general_ci | | collation_server | utf8_general_ci | +----------------------+-----------------+ 3 rows in set (0.00 sec) 字符集配置完成。\n添加用户，设置权限 创建用户\nmysql\u0026gt; create user username@localhost identified by \u0026#39;password\u0026#39;; 直接创建用户并授权\nmysql\u0026gt; grant all on *.* to username@localhost identified by \u0026#39;password\u0026#39;; 授予外网登陆权限\nmysql\u0026gt; grant all privileges on *.* to username@\u0026#39;%\u0026#39; identified by \u0026#39;password\u0026#39;; 授予权限并且可以授权\nmysql\u0026gt; grant all privileges on *.* to username@\u0026#39;hostname\u0026#39; identified by \u0026#39;password\u0026#39; with grant option;  简单的用户和权限配置基本就这样了。\n如果只授予部分权限可以将其中all privileges或者all改为select,insert,update,delete,create,drop,index,alter,grant,references,reload,shutdown,process,file其中一部分。\n MYSQL 远程连接 MySQL 默认只支持本地的连接，如果需要远程连接可以修改 mysql 库下的 user 表的l ocalhost 为 % 即可，然后刷新配置信息\n# 将host设置为%表示任何ip都能连接mysql，当然您也可以将host指定为某个ip mysql\u0026gt; update user set host=\u0026#39;%\u0026#39; where user=\u0026#39;root\u0026#39; and host=\u0026#39;localhost\u0026#39;; # 刷新权限表，使配置生效 mysql\u0026gt; flush privileges; MySQL 创建用户与授权 创建用户 命令:\nmysql\u0026gt; CREATE USER \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39; IDENTIFIED BY \u0026#39;password\u0026#39;; 说明：\n username：你将创建的用户名 host：指定该用户在哪个主机上可以登陆，如果是本地用户可用localhost，如果想让该用户可以从任意远程主机登陆，可以使用通配符% password：该用户的登陆密码，密码可以为空，如果为空则该用户可以不需要密码登陆服务器  例子：\nmysql\u0026gt; CREATE USER \u0026#39;dog\u0026#39;@\u0026#39;localhost\u0026#39; IDENTIFIED BY \u0026#39;123456\u0026#39;; mysql\u0026gt; CREATE USER \u0026#39;pig\u0026#39;@\u0026#39;192.168.1.101_\u0026#39; IDENDIFIED BY \u0026#39;123456\u0026#39;; mysql\u0026gt; CREATE USER \u0026#39;pig\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;123456\u0026#39;; mysql\u0026gt; CREATE USER \u0026#39;pig\u0026#39;@\u0026#39;%\u0026#39; IDENTIFIED BY \u0026#39;\u0026#39;; mysql\u0026gt; CREATE USER \u0026#39;pig\u0026#39;@\u0026#39;%\u0026#39;; 授权 命令:\nmysql\u0026gt; GRANT privileges ON databasename.tablename TO \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39; 说明:\n privileges：用户的操作权限，如SELECT，INSERT，UPDATE等，如果要授予所的权限则使用ALL databasename：数据库名 tablename：表名，如果要授予该用户对所有数据库和表的相应操作权限则可用*表示，如*.*  例子:\nmysql\u0026gt; GRANT SELECT, INSERT ON test.user TO \u0026#39;pig\u0026#39;@\u0026#39;%\u0026#39;; mysql\u0026gt; GRANT ALL ON *.* TO \u0026#39;pig\u0026#39;@\u0026#39;%\u0026#39;; mysql\u0026gt; GRANT ALL ON maindataplus.* TO \u0026#39;pig\u0026#39;@\u0026#39;%\u0026#39;; 注意: 用以上命令授权的用户不能给其它用户授权，如果想让该用户可以授权，用以下命令:\nmysql\u0026gt; GRANT privileges ON databasename.tablename TO \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39; WITH GRANT OPTION; 设置与更改用户密码 命令:\nmysql\u0026gt; SET PASSWORD FOR \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39; = PASSWORD(\u0026#39;newpassword\u0026#39;); 如果是当前登陆用户用：\nmysql\u0026gt; SET PASSWORD = PASSWORD(\u0026#34;newpassword\u0026#34;); 例子:\nmysql\u0026gt; SET PASSWORD FOR \u0026#39;pig\u0026#39;@\u0026#39;%\u0026#39; = PASSWORD(\u0026#34;123456\u0026#34;); 撤销用户权限 命令:\nmysql\u0026gt; REVOKE privilege ON databasename.tablename FROM \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39;; 说明: privilege, databasename, tablename：同授权部分\n例子:\nmysql\u0026gt; REVOKE SELECT ON *.* FROM \u0026#39;pig\u0026#39;@\u0026#39;%\u0026#39;; 注意: 假如你在给用户'pig'@'%'授权的时候是这样的（或类似的）：GRANT SELECT ON test.user TO 'pig'@'%'，则在使用REVOKE SELECT ON *.* FROM 'pig'@'%';命令并不能撤销该用户对test数据库中user表的SELECT操作。相反，如果授权使用的是GRANT SELECT ON *.* TO 'pig'@'%';则REVOKE SELECT ON test.user FROM 'pig'@'%';命令也不能撤销该用户对 test 数据库中 user 表的 Select 权限。具体信息可以用命令SHOW GRANTS FOR 'pig'@'%';查看。\n删除用户 命令:\nmysql\u0026gt; DROP USER \u0026#39;username\u0026#39;@\u0026#39;host\u0026#39;; mysql 数据库使用总结 修改用户密码，以root为例 知道root密码，需要修改  方法a. 登入数据库来修改  $ mysql -uroot -p /*输入密码进入*/ /* 第一个方式：直接编辑数据库字段 */ MariaDB [(none)]\u0026gt; use mysql; MariaDB [mysql]\u0026gt; UPDATE user SET password=password(\u0026#39;newpassword\u0026#39;) WHERE user=\u0026#39;root\u0026#39;; MariaDB [mysql]\u0026gt; flush privileges; MariaDB [mysql]\u0026gt; exit /* 第二个方式：修改密码，不用进入mysql */ MariaDB [(none)]\u0026gt; SET password for \u0026#39;root\u0026#39;@\u0026#39;localhost\u0026#39;=password(\u0026#39;newpassword\u0026#39;); MariaDB [(none)]\u0026gt; exit;  方法b. 使用 mysqladmin  # 这样做不好的地方在于密码都在命令行给明文显示出来了 $ mysqladmin -uroot -poldpassword password newpassword # 或者 $ mysqladmin -uroot -p password newpassword 忘记 root 密码，需要重置 $ systemctl stop mariadb # 先停掉当前的mysql进程，不然执行下一步说进程已经存在 $ mysqld_safe --skip-grant-tables \u0026amp; # 后台直接这个mysql，界面中还会出现日志，直接ctrl+c进入命令行输入 $ ps -ef | grep mariadb # 看进程，会突出显示--skip-grant-tables mysql 3607 3368 0 18:05 pts/0 00:00:00 /usr/libexec/mysqld --basedir=/usr --datadir=/var/lib/mysql --plugin-dir=/usr/lib64/mysql/plugin --user=mysql --skip-grant-tables --log-error=/var/log/mariadb/mariadb.log --pid-file=/var/run/mariadb/mariadb.pid --socket=/var/lib/mysql/mysql.sock $ mysql # 直接进入mysql，不需要密码等，执行第一步中方法a里两种方式中任何一种即可 MariaDB [(none)]\u0026gt; use mysql; MariaDB [mysql]\u0026gt; UPDATE user SET password=password(\u0026#39;newpassword\u0026#39;) WHERE user=\u0026#39;root\u0026#39;; MariaDB [mysql]\u0026gt; flush privileges; MariaDB [mysql]\u0026gt; exit; /* 这个时候用参数--skip-grant-tables启动的mysql已经会要求输入密码才能进入了 */ $ pkill mysql # 用pkill来杀,kill不死，kill之后自动起来一个 $ systemctl start mariadb # 启动正常的mysql 更改 mysql 参数，以 max_allowed_packet 为例  方法1. 编辑配置文件  $ vim /etc/my.cnf max_allowed_packet=20M max_connections = 500 $ systemctl restart mariadb # 重启生效  方法2. 登入数据库来设置，不过重启就会复原，推荐直接用上面的更改配置文件的方法  MariaDB [(none)]\u0026gt; show variables like \u0026#39;max_allowed_packet\u0026#39;; +--------------------+---------+ | Variable_name | Value | +--------------------+---------+ | max_allowed_packet | 1048576 | +--------------------+---------+ 1 row in set (0.00 sec) MariaDB [(none)]\u0026gt; set global max_allowed_packet = 2*1024*1024*10; /*把query最大运行包大小从默认的1M调整为20M*/ 本文主要记录一些 mysql 日常使用的命令，供以后查询。  更改root密码  $ mysqladmin -uroot password \u0026#39;yourpassword\u0026#39;  本地登录mysql  $ mysql -uroot -ppassword $ mysql -uroot -p # 输入密码  远程登陆mysql服务器  $ mysql -uroot -p -h192.168.137.10 -P3306 $ mysql [-h hostname] [-u username] -p  查询数据库  mysql\u0026gt; show databases;  进入某个数据库  mysql\u0026gt; use databasename;  列出数据库中的表  mysql\u0026gt; show tables;  查看某个表全部字段  mysql\u0026gt; desc slow_log; mysql\u0026gt; show create table slow_log\\G; // 不仅可以显示表信息，还可以显示建表语句  查看当前用户  mysql\u0026gt; select user();  查看当前所在数据库  mysql\u0026gt; select database();  创建新数据库（可以指定字符集）  mysql\u0026gt; create database db1 charset utf8;  创建数据库(mysql:sql create database新建utf8mb4数据库)  mysql\u0026gt; create database db2 default character set utf8mb4 collate utf8mb4_general_ci;  创建新表  mysql\u0026gt; create table t1 (`id` int(4), `name` char(40));  查看数据库版本  mysql\u0026gt; select version();  查看数据库状态  mysql\u0026gt; show status; // 当前会话状态 mysql\u0026gt; show global status; // 全局数据库状态 mysql\u0026gt; show slave status\\G; // 查看主从数据库状态信息  查询数据库参数  mysql\u0026gt; show variables;  修改数据库参数  mysql\u0026gt; show variables like \u0026#39;max_connect%\u0026#39;; mysql\u0026gt; set global max_connect_errors = 1000; // 重启数据库会失效，要在配置文件中修改  查看当前数据库队列  mysql\u0026gt; show processlist;  创建普通用户并授权给某个数据库  mysql\u0026gt; grant all on databasename.* to \u0026#39;user1\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;123456\u0026#39;;  查询表数据  mysql\u0026gt; select * from mysql.db; // 查询该表中的所有字段 mysql\u0026gt; select count(*) from mysql.user; // count(*)表示表中有多少行 mysql\u0026gt; select db,user from mysql.db; // 查询表中的多个字段 mysql\u0026gt; select * from mysql.db where host like \u0026#39;10.0.%\u0026#39;; // 在查询语句中可以使用万能匹配 “%”  插入一行数据  mysql\u0026gt; insert into db1.t1 values (1, \u0026#39;abc\u0026#39;);  更改表的某一行数据  mysql\u0026gt; update db1.t1 set name=\u0026#39;aaa\u0026#39; where id=1;  清空表数据  mysql\u0026gt; truncate table db1.t1;  删除表  mysql\u0026gt; drop table db1.t1;  清空数据库中的所有表（数据库名是eab12）  $ mysql -N -s information_schema -e \u0026#34;SELECT CONCAT(\u0026#39;TRUNCATE TABLE \u0026#39;,TABLE_NAME,\u0026#39;;\u0026#39;) FROM TABLES WHERE TABLE_SCHEMA=\u0026#39;eab12\u0026#39;\u0026#34; | mysql -f eab12  删除数据库  mysql\u0026gt; drop database db1;  数据库备份  $ mysqldump -uroot -p\u0026#39;yourpassword\u0026#39; mysql \u0026gt;/tmp/mysql.sql  数据库恢复  $ mysql -uroot -p\u0026#39;yourpassword\u0026#39; mysql \u0026lt;/tmp/mysql.sql  新建普通用户  mysql\u0026gt; CREATE USER name IDENTIFIED BY \u0026#39;ssapdrow\u0026#39;;  更改普通用户密码  mysql\u0026gt; SET PASSWORD FOR name=PASSWORD(\u0026#39;fdddfd\u0026#39;);  查看name用户权限  mysql\u0026gt; SHOW GRANTS FOR name;  脚本中执行mysql命令  $ mysql -uuser -ppasswd -e\u0026#34;show databases\u0026#34; $ echo \u0026#34;show databases\u0026#34;|mysql -uuser -ppassword  以下是执行大量mysql语句采用的方式  $ mysql -uuser -hhostname -ppasswd \u0026lt;\u0026lt;EOF mysql语句 EOF ","date":1571309771,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1571309771,"objectID":"2407c9ce42eb10b8c4c46b114e92c8c7","permalink":"https://wangxinping.github.io/post/welcome-to-mysql/","publishdate":"2019-10-17T18:56:11+08:00","relpermalink":"/post/welcome-to-mysql/","section":"post","summary":"CentOS 7 使用 MariaDB 代替 MYSQL 本文记录在 CentOS 7 中使用 MySQL/MariaDB 的一些用法和一些要注意的事情 安装 MariaDB 安装MariaDB $ yum install mariadb mariadb-server mariadb-devel 启动MariaDB $ systemctl start mariadb # 或者 $ service mariadb","tags":["MySQL"],"title":"Welcome to MySQL","type":"post"},{"authors":["WangXinping"],"categories":["Vim"],"content":"Vim 基本操作 Vim 分为三种模式：\n 输入模式：这就是很普通的编辑器一样，光标在某个位置上闪烁，表示我们可以输入内容了。 普通模式：在输入模式下按下 Esc 键可以退出输入模式，进入到普通模式。 命令模式：执行搜索、替换等命令或调用插件。  普通模式是 Vim 的一大特色，能够进行很多操作，比如：\n 快速移动光标 快速替换、删除某些内容 进入输入模式或命令模式  使用 vim 打开文件后，默认进入普通模式，如果我们要编辑文本，可以按下 i 进入编辑模式，编辑完后再按下 Esc 键可以退出输入模式，进入到普通模式。\n如果想退出 vim，则需要借助命令模式。按下 : 并输入以下内容之一：\n q：退出 q!：如果对文件作了修改，无法用 q 退出，此时 q! 表示丢弃修改并退出 wq：保存并退出  Vim 光标移动 上一节中我们介绍了 Vim 的基本操作，靠着 i、q 等指令，配合上方向键，基本上能在 Vim 的世界里幸存下来了。勉强编辑一下服务器上的文件不是问题。\n如果你的打字手势标准的话，你会发现方向键其实挺难触摸到，至少会破坏右手的姿势。因此在 Vim 中不鼓励使用方向键，可以用 hjkl 来代替：\n h：向左移动一个字符 l：向右移动一个字符 j：向下移动一行 k：向上移动一行  重复移动 如果要向上移动 5 行，或者向右移动 10 个字符，我们是不是要重复按下很多次呢？显然只有方向键才要这么做，Vim 中可以用数字来表示重复：\n 10j: 向下移动 10 行 5l: 向右移动五个字符  这个操作虽然简单，但是引出了贯穿 Vim 始终的核心思想：就像英语、中文有语法一样，Vim 也有语法。\nVim 的操作可以由若干个部分组合而成，每个部分又有多个可选值（比如光标移动就分上下左右）。Vim 的入门难度高，是因为每个部分都要学习，一下子需要掌握很多新知识点。但 Vim 后期的学习成本很低，因为无非就是各种组合而已。\n还是以光标移动为例，5j 由重复次数和动作组成，后面我们会介绍更多的动作，而且它们的前面都可以加上数字表示重复。\n单词移动 得益于普通模式和语法，Vim 支持强大的单词间移动：\n w 移动光标到下一个单词的词首(word) b 移动光标到上一个单词的词首(begin) e 移动光标到下一个单词的结尾(end) ge 移动光标到上一个单词的结尾(不知道怎么解释了。。。)  这里的单词是有严格约定的，而且不是那么显然，所以个人感觉这几个键并不是特别好用（往往你以为的跳转地址和真实跳转地址可能并不一致）。\n不过如果你把空格当做单词的分隔符，倒是有比较简单的跳转方式，前三个命令都有大写格式：\n W 移动光标到下一个单词的词首(word) B 移动光标到上一个单词的词首(begin) E 移动光标到下一个单词的结尾(end)  这里的单词特指以空格分割。\n同样的，这些移动也支持重复任意多次。\n行和屏幕移动 在行内，^ 表示移动到行首，它会自动忽视掉行首的空格，大部分情况下这是符合预期的，尤其是在代码缩进的情况下。如果想回到行首的空格上，可以用 0。$ 表示移动到行尾。\nVim 的翻页快捷键是：\n Ctrl + f：向后翻一页（forward） Ctrl + b：向前翻一页（backward） Ctrl + d：向后翻半页（down） Ctrl + u：向前翻半页（up）  还有几个快捷键可以用于调整页面布局：\n zz：让当前行居中显示，方便浏览上下文 zt：让当前行显示在最上方，方便浏览后面的内容（t 表示 top） zb：让当前行显示在最下方，方便浏览前面的内容（b 表示 bottom）  高级移动 代码中经常遇到括号（包括 (、[ 和 {，也就是大中小三中括号），如果当前光标停留在括号上，按下 % 即可匹配到对应的括号上。\n除此以外，* 和 # 分别表示匹配当前光标下的单词，并移动到下一个单词和上一个单词\n文本编辑 阅读完前两节，相信读者以经能够在 Vim 中自如的移动光标了，不过我们的编辑方式还比较简陋，只能进入编辑模式，像往常一样逐个字符的输入和删除，本节会介绍一些更高级的操作。\n基础文本编辑 在普通模式下，按下 o 会快速进入输入模式，并且在下一行进行编辑。如果按下大写的 O 会在上一行编辑。\n如果想在当前光标位置开始编辑，可以按下 a 或 i，前者表示在光标所在字符的右侧开始编辑，后者表示在左侧开始编辑。\n我们还可以用 I 前往行头开始编辑，或者用 A 跳转到行尾编辑。\n按下 dd 可以快速删除一行，此时被删除的那一行会保存在 Vim 的剪贴板中。这一点类似于系统的 Command + X 剪切，我们可以通过配置 Vim 来选择是否要与系统共享剪贴板。\n普通模式下，按下 p 可以把 Vim 剪贴板中的内容再拷贝出来，注意这里总是会拷贝到下一行或者光标的右侧。因此如果想交换当前行和下一行，可以输入：ddp，这是因为当前被删除的行会复制到下一行的下面。\n如果只想复制，不想删除，可以把命令 p 换成 y（表示：yank）。如果想删除后进入编辑模式，可以把 p 换成 c，比如 cc 表示删除当前行并且从行首开始编辑。\n 注意这里的 p、c、y、d 都是动作，和前面说的 j、k、l、h、w、b、e 一样，都支持用数字来重复，比如 2dd 表示删除两行。\n 撤销与重做 如果想撤销上一次修改，可以用 u，类似于系统的 Command + z 快捷键。\n如果想重做，可以用 Ctrl + R，类似于系统的 Command + Shift + z 快捷键。\n文本对象 Vim 的文本对象能极大幅度的提高编辑效率，也是 Vim 进阶之路上必须要掌握的概念。\n对于上文介绍的 c、d、y 这些动作来说，作为单独的动作用处并不大，无非就是连续按两下对当前行做一些操作，而文本对象则扮演了语法中名词的概念，提供了更细粒度的操作。比如以下几种操作：\n diw： 删除一个单词（word） ca\u0026quot;：删除双引号内的文本并编辑（包含双引号自身） yi\u0026quot;：复制双引号内的文本（不包含双引号自身） dtx：向右删除，直到遇到遇到字符 x（不包含 x）  以上三个命令都属于同一大类操作，它们普遍遵循以下模式：\n 命令 = 动作 + 数量 + 描述词 + 文本对象\n 这类命令通常由三个或四个字母组成：\n 第一个字母是动词，包括上文介绍的 c、y、d 等，表示你这个命令的主要目的。 第二个字母是可选的，表示重复几次 第三个字母是对范围的描述，比如 a 表示包含边界，i 不包含，t 表示向右查找，T 向左。 第四个字母是文本对象，可以是内容的字面量描述，比如 \u0026quot;、'、`、\u0026lt;、{、( 等等，也可以是固定单词  这里详细介绍下文本对象，除了字面量外，以下单词有特定的含义：\n p：表示段落 s：表示句子 w：表示单词 t：特指标签，一定要具备 \u0026lt;xx\u0026gt;abc\u0026lt;/xx\u0026gt; 的结构，此时的 t 代表 abc   对于字面量的文本对象，除了 \u0026quot;、' 和 ` 这三个引号外，另外几个括号都可以用 b 来表示（block），这样就不用区分大中小和尖括号了。\n 搜索与替换 使用 / 进行搜索，搜索默认是匹配大小写的，使用 /pattern\\c 可以强制忽略大小写，使用 /pattern\\C 可以强制匹配大小写。\n使用 :范围s/oldpattern/newpattern/替换模式 可以进行替换。\n如果我们已经进行过搜索，那么 oldpattern 可以省略不写，默认就是上一次的搜索内容。\n最常用的范围是 begin, end，其中 begin 是开始行号，end 是结束行号，表示在第 begin 行到第 end 行之间进行替换，比如：:1,10s/hello/hallo/g 表示把第 1 - 10 行中所有的 hello 换成 hallo。\n范围还有一些简单的表示法：\n .,10 表示当前行到第 10 行，点表示当前行 .,$ 表示当前行到文件末尾，美刀符号表示文件结尾 % 表示 1,$，也就是整个文件，比如全文替换通常写成 :%s/old/new/g .,+2 表示当前行和接下来的两行  上文反复提到的字母 g 其实是一种替换模式，表示替换这个范围内所有出现的 oldpattern，如果不写则只替换第一次出现。常用的模式还有 c，表示替换需要确认（Confirm），i 表示大小写不敏感，I 表示大小写敏感。\n大小写切换 以下是几个常用的，切换大小写的命令\n guu 当前行全部小写，gUU 当前行全部大写 ~ 当前光标下的字符切换大小写, 3~ 当前光标下后面三个字符切换大小写 guiw 当前单词全部小写，gUiw 当前单词全部大写 g~iw 当前单词每个字符大小写交换  列操作 如果有多行文本要做相同的操作，可以借助 Vim 中列操作的概念来快速完成，举一个实际实际的例子，假设有以下这段代码：\nint a; int b; int c; // ... int z; 有一天我们发现 int 不是很准确，要改成：\nuint8_t a; uint8_t b; uint8_t c; // ... uint8_t z; 难道还要手动复制粘贴不成？请看列操作大法：\n 首先按下 Ctrl + V 进入列操作模式 然后用 j、k 进行跳转，表示你要操作多少行 这时你对每一行的操作都会应用到所有行上，比如输入 ec，删除单词进入编辑模式 输入 uint_8，按下 Esc 退出编辑，Vim 会自动应用到所有行上。  宏 列操作的本质是多行同时操作，如果每一行的操作类似，但都有细微差别，就需要引入 录制、回放 的概念了。此时可以用 Vim 中的宏。\n一个典型的场景是，我们在写 Markdown：\n1. 第一条 2. 第二条 3. 第三题 ... 10. 第十条 写着写着突然发现，第一条和第二条中间还要加一条，左边的序号就不好处理了，因为我们要把原来的序号 2 到 10 分别加一。\n在 Vim 中，我们“只”需要输入 qajC-aq6@a，相信你一定很想打我，这特么一点也不简单啊。别急，拆开来看：\nqa（q 表示开始录制宏，a 表示录制内容存储在寄存器 a 中） j（向下一行） Ctrl + a（数字加一） q（再按一次 q 表示结束录制） 6@a（把存储在寄存器 a 中的宏执行 6 次） 是不是感觉 So Easy!\n","date":1571309585,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1571309585,"objectID":"5c94c2760c24d106ce8f14fb17455a4c","permalink":"https://wangxinping.github.io/post/welcome-to-vim/","publishdate":"2019-10-17T18:53:05+08:00","relpermalink":"/post/welcome-to-vim/","section":"post","summary":"Vim 基本操作 Vim 分为三种模式： 输入模式：这就是很普通的编辑器一样，光标在某个位置上闪烁，表示我们可以输入内容了。 普通模式：在输入模式下按下 Esc 键可","tags":["Vim"],"title":"Welcome to Vim","type":"post"},{"authors":["WangXinping"],"categories":["JetBrains"],"content":" 根据官方文档翻译修正（个别快捷键与官方文档中不符）而来 在 IntelliJ IDEA 中有两个 Mac 版本的快捷键，一个叫做：Mac OS X，一个叫做：Mac OS X 10.5+ 目前用的一般是最新的：Mac OS X 10.5+ 有两套的原因   建议将 Mac 系统中与 IntelliJ IDEA 冲突的快捷键取消或更改，不建议改 IntelliJ IDEA 的默认快捷键\n Mac键盘符号和修饰键说明  ⌘ Command ⇧ Shift ⌥ Option ⌃ Control ↩︎ Return/Enter ⌫ Delete ⌦ 向前删除键（Fn+Delete） ↑ 上箭头 ↓ 下箭头 ← 左箭头 → 右箭头 ⇞ Page Up（Fn+↑） ⇟ Page Down（Fn+↓） Home Fn + ← End Fn + → ⇥ 右制表符（Tab键） ⇤ 左制表符（Shift+Tab） ⎋ Escape (Esc)  Editing（编辑）  Control + Space 基本的代码补全（补全任何类、方法、变量） Control + Shift + Space 智能代码补全（过滤器方法列表和变量的预期类型） Command + Shift + Enter 自动结束代码，行末自动添加分号 Command + P 显示方法的参数信息 Control + J 快速查看文档 Shift + F1 查看外部文档（在某些代码上会触发打开浏览器显示相关文档） Command + 鼠标放在代码上 显示代码简要信息 Command + F1 在错误或警告处显示具体描述信息 Command + N, Control + Enter 生成代码（getter、setter、构造函数、hashCode/equals,toString） Control + O 覆盖方法（重写父类方法） Control + I 实现方法（实现接口中的方法） Command + Option + T 包围代码（使用if..else, try..catch, for, synchronized等包围选中的代码） Command + / 注释/取消注释与行注释 Command + Option + / 注释/取消注释与块注释 Option + 方向键上 连续选中代码块 Option + 方向键下 减少当前选中的代码块 Control + Shift + Q 显示上下文信息 Option + Enter 显示意向动作和快速修复代码 Command + Option + L 格式化代码 Control + Option + O 优化import Control + Option + I 自动缩进线 Tab / Shift + Tab 缩进代码 / 反缩进代码 Command + X 剪切当前行或选定的块到剪贴板 Command + C 复制当前行或选定的块到剪贴板 Command + V 从剪贴板粘贴 Command + Shift + V 从最近的缓冲区粘贴 Command + D 复制当前行或选定的块 Command + Delete 删除当前行或选定的块的行 Control + Shift + J 智能的将代码拼接成一行 Command + Enter 智能的拆分拼接的行 Shift + Enter 开始新的一行 Command + Shift + U 大小写切换 Command + Option + Shift + ] / Command + Option + Shift + [ 选择直到代码块结束/开始 Command + Shift + ] / Command + Shift + [ 返回光标或选择到前 / 后一操作效果 Option + Fn + Delete 删除到单词的末尾 Option + Delete 删除到单词的开头 Command + 加号 / Command + 减号 展开 / 折叠代码块 Command + Shift + 加号 展开所以代码块 Command + Shift + 减号 折叠所有代码块 Command + W 关闭活动的编辑器选项卡  Search/Replace（查询/替换）  Double Shift 查询任何东西 Command + F 文件内查找 Command + G 查找模式下，向下查找 Command + Shift + G 查找模式下，向上查找 Command + R 文件内替换 Command + Shift + F 全局查找（根据路径） Command + Shift + R 全局替换（根据路径） Command + Shift + S 查询结构（Ultimate Edition 版专用，需要在Keymap中设置） Command + Shift + M 替换结构（Ultimate Edition 版专用，需要在Keymap中设置）  Usage Search（使用查询）  Option + F7 / Command + F7 在文件中查找用法 / 在类中查找用法 Command + Shift + F7 在文件中突出显示的用法 Command + Option + F7 显示用法  Compile and Run（编译和运行）  Command + F9 编译Project Command + Shift + F9 编译选择的文件、包或模块 Control + Option + R 弹出 Run 的可选择菜单 Control + Option + D 弹出 Debug 的可选择菜单 Control + R 运行 Control + D 调试 Control + Shift + R, Control + Shift + D 从编辑器运行上下文环境配置  Debugging（调试）  F8 进入下一步，如果当前行断点是一个方法，则不进入当前方法体内 F7 进入下一步，如果当前行断点是一个方法，则进入当前方法体内，如果该方法体还有方法，则不会进入该内嵌的方法中 Shift + F7 智能步入，断点所在行上有多个方法调用，会弹出进入哪个方法 Shift + F8 跳出 Option + F9 运行到光标处，如果光标前有其他断点会进入到该断点 Option + F8 计算表达式（可以更改变量值使其生效） Command + Option + R 恢复程序运行，如果该断点下面代码还有断点则停在下一个断点上 Command + F8 切换断点（若光标当前行有断点则取消断点，没有则加上断点） Command + Shift + F8 查看断点信息  Navigation（导航）  Command + O 查找类文件 Command + Shift + O 查找所有类型文件、打开文件、打开目录，打开目录需要在输入的内容前面或后面加一个反斜杠/ Command + Option + O 前往指定的变量 / 方法 Control + 方向键左 / Control + 方向键右 左右切换打开的编辑tab页 F12 返回到前一个工具窗口 Esc 从工具窗口进入代码文件窗口 Shift + Esc 隐藏当前或最后一个活动的窗口，且光标进入代码文件窗口 Command + Shift + F4 关闭活动run/messages/find/\u0026hellip; tab Command + L 在当前文件跳转到某一行的指定处 Command + E 显示最近打开的文件记录列表 Option + 方向键左 / Option + 方向键右 光标跳转到当前单词 / 中文句的左 / 右侧开头位置 Command + Option + 方向键左 / Command + Option + 方向键右 退回 / 前进到上一个操作的地方 Command + Shift + Delete 跳转到最后一个编辑的地方 Option + F1 显示当前文件选择目标弹出层，弹出层中有很多目标可以进行选择(如在代码编辑窗口可以选择显示该文件的Finder) Command + B / Command + 鼠标点击 进入光标所在的方法/变量的接口或是定义处 Command + Option + B 跳转到实现处，在某个调用的方法名上使用会跳到具体的实现处，可以跳过接口 Option + Space, Command + Y 快速打开光标所在方法、类的定义 Control + Shift + B 跳转到类型声明处 Command + U 前往当前光标所在方法的父类的方法 / 接口定义 Control + 方向键下 / Control + 方向键上 当前光标跳转到当前文件的前一个/后一个方法名位置 Command + Option + ] / Command + Option + [ 移动光标到当前所在代码的花括号开始/结束位置 Command + ] / Command + [ 返回光标或选择到前 / 后一操作效果 Command + F12 弹出当前文件结构层，可以在弹出的层上直接输入进行筛选（可用于搜索类中的方法） Control + H 显示当前类的层次结构 Command + Shift + H 显示方法层次结构 Control + Option + H 显示调用层次结构 F2 / Shift + F2 跳转到下一个/上一个突出错误或警告的位置 F4 / Command + 方向键下 编辑/查看代码源 Option + Home 显示到当前文件的导航条 F3 选中文件/文件夹/代码行，添加/取消书签 Option + F3 选中文件/文件夹/代码行，使用助记符添加/取消书签 Control + 0...Control + 9 定位到对应数值的书签位置 Command + F3 显示所有书签  Refactoring（重构）  F5 复制文件到指定目录 F6 移动文件到指定目录 Command + Delete 在文件上为安全删除文件，弹出确认框 Shift + F6 重命名文件 Command + F6 更改签名 Command + Option + N 一致性 Command + Option + M 将选中的代码提取为方法 Command + Option + V 提取变量 Command + Option + F 提取字段 Command + Option + C 提取常量 Command + Option + P 提取参数  VCS/Local History（版本控制/本地历史记录）  Command + K 提交代码到版本控制器 Command + T 从版本控制器更新代码 Option + Shift + C 查看最近的变更记录 Control + C 快速弹出版本控制器操作面板  Live Templates（动态代码模板）  Command + Option + J 弹出模板选择窗口，将选定的代码使用动态模板包住 Command + J 插入自定义动态代码模板  General（通用）  Command + 1...Command + 9 打开相应编号的工具窗口 Command + S 保存所有 Command + Option + Y 同步、刷新 Control + Command + F 切换全屏模式 Command + Shift + F12 切换最大化编辑器 Option + Shift + F 添加到收藏夹 Option + Shift + I 检查当前文件与当前的配置文件 Control + `快速切换当前的scheme（切换主题、代码样式等） Command + , 打开IDEA系统设置 Command + ; 打开项目结构对话框 Shift + Command + A 查找动作（可设置相关选项） Control + Shift + Tab 编辑窗口标签和工具窗口之间切换（如果在切换的过程加按上delete，则是关闭对应选中的窗口）  Other（一些官方文档上没有体现的快捷键）  Command + Shift + 8 竖编辑模式  ","date":1571301964,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1571301964,"objectID":"807fcb1439a567ccf55f3f0121997a01","permalink":"https://wangxinping.github.io/post/intellij-idea-keymap-for-mac/","publishdate":"2019-10-17T16:46:04+08:00","relpermalink":"/post/intellij-idea-keymap-for-mac/","section":"post","summary":"根据官方文档翻译修正（个别快捷键与官方文档中不符）而来 在 IntelliJ IDEA 中有两个 Mac 版本的快捷键，一个叫做：Mac OS X，一个叫做：Mac OS X 10.5+ 目前用的一般","tags":["JetBrains","IDE"],"title":"Intellij Idea Keymap for Mac","type":"post"},{"authors":["WangXinping"],"categories":["Hugo","Academic"],"content":"Academic is a website builder for Hugo. The Academic framework enables you to easily create a beautifully simple website using the Hugo static site generator in a few minutes.\n","date":1571292450,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1571292450,"objectID":"8513f6ba0c3517cac5c153e1ce57d71c","permalink":"https://wangxinping.github.io/post/welcome-to-academic/","publishdate":"2019-10-17T14:07:30+08:00","relpermalink":"/post/welcome-to-academic/","section":"post","summary":"Academic is a website builder for Hugo. The Academic framework enables you to easily create a beautifully simple website using the Hugo static site generator in a few minutes.","tags":["Hugo","Academic"],"title":"Welcome to Academic","type":"post"},{"authors":["WangXinping"],"categories":["Hugo"],"content":"Hugo is a fast and modern static site generator written in Go, like Jekyll written in ruby and Hexo written in node.\n","date":1571288823,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1571288823,"objectID":"4ca31bb448ce56d1917a31d2aac299e9","permalink":"https://wangxinping.github.io/post/welcome-to-hugo/","publishdate":"2019-10-17T13:07:03+08:00","relpermalink":"/post/welcome-to-hugo/","section":"post","summary":"Hugo is a fast and modern static site generator written in Go, like Jekyll written in ruby and Hexo written in node.","tags":["Hugo"],"title":"Welcome to Hugo","type":"post"}]